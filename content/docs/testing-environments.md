---
id: testing-environments
title: Среды тестирования
permalink: docs/testing-environments.html
prev: testing-recipes.html
---

<!-- Этот документ предназначен для людей, которые знают, как использовать JavaScript и умеют писать тесты. Он показывает различия в средах тестирования React-компонентов и как эти различия повлияют на тесты, которые они пишут. Документ, в основном, рассказывает про основанные на web react-dom-компоненты и кратко упоминает про другие рендереры. -->

Этот документ рассказывает про факторы, которые могут повлиять на среду тестирования, и дает рекомендации для некоторых случаев.

### Исполнители тестов {#test-runners}

Исполнители тестов, такие как [Jest](https://jestjs.io/), [mocha](https://mochajs.org/), [ava](https://github.com/avajs/ava) позволяют писать тесты на JavaScript, и запускать их в процессе разработки. Кроме того, наборы тестов запускаются в рамках непрерывной интеграции.

- Jest хорошо совместим с React-проектами, поддерживает такие возможности, как фиктивные [модули](#mocking-modules) и [таймеры](#mocking-timers), работа с [`jsdom`](#mocking-a-rendering-surface). **Если вы используете Create React App, [Jest уже предустановлен](https://facebook.github.io/create-react-app/docs/running-tests) с полезными настройками по-умолчанию.**
- Библиотеки, такие как [mocha](https://mochajs.org/#running-mocha-in-the-browser) хорошо работают в среде с настоящим браузером и помогут в тестах, которым она требуется.
- «Сквозные» тесты нужны для тестирования длинных последовательностей действий через несколько страниц и требуют [другой настройки](#end-to-end-tests-aka-e2e-tests).

### Подмена области рендеринга {#mocking-a-rendering-surface}

Тесты часто запускаются в среде, у которой нет доступка к реальной области рендеринга, например браузера. В этом случае мы рекомендуем имитировать работу браузера с помощью [`jsdom`](https://github.com/jsdom/jsdom) – легковесной реализации браузера, которая запускается в Node.js.

В большинстве слуаев, `jsdom` ведёт себя как обычный браузер, но без некоторых возможностей, например [разметки и навигации](https://github.com/jsdom/jsdom#unimplemented-parts-of-the-web-platform). Несмотря на это, `jsdom` полезен в большинстве тестов web-компонентов, так как выполняется быстрее, чем запуск браузера для каждого отдельного теста и запускается рядом с вашими тестами, что позволяет писать код проверки предполагаемого вывода на отрендеренную DOM.

Как настоящий браузер, `jsdom` имитируют действия пользователя: тесты могут создавать события на DOM-узлах, наблюдать за ними и проверять предпологаемые побочные эффекты от этих действий [<small>(пример)</small>](/docs/testing-recipes.html#events).

Большое количество UI-тестов можно написать описанным выше способом: Jest запускает тесты, компонент рендерится в `jsdom`, действия пользователя описываются в виде последовательности браузерных событий и оборачивается вспомогательной функцией `act()` [<small>(пример)</small>](/docs/testing-recipes.html). Кстати, много тестов для библиотеки React написано таким образом.

Если вы пишете библиотеку, которая в основном тестирует поведение специфичное для браузера, например, работа с разметкой страницы или настоящие элементы `input`, используйте фреймворк, такой как, [mocha.](https://mochajs.org/)

В среде, где вы _не можете_ имитировать DOM (например, тестирование React Native-компонентов в Node.js), используйте [вспомогательные функции имитации события](https://reactjs.org/docs/test-utils.html#simulate), чтобы имитировать взаимодействие с элементами. В качестве альтернативы, можно использовать вспомогательную функцию `fireEvent` из [`@testing-library/react-native`](https://testing-library.com/docs/native-testing-library).

Фреймворки, такие как [Cypress](https://www.cypress.io/), [puppeteer](https://github.com/GoogleChrome/puppeteer) и [webdriver](https://www.seleniumhq.org/projects/webdriver/) полезны для запуска [«сквозных» тестов](#end-to-end-tests-aka-e2e-tests).

### Подмена функций {#mocking-functions}

При написании тестов, иногда требуется подменить части кода, которые не имеют аналога внутри среды тестирования (например, проверка статуса через `navigator.onLine` внутри Node.js). Тесты также могут «следить» за некоторыми функциями и видеть, как другие части теста взаимодействуют с ними. В этом случае полезно иметь возможность выборочно подменить эти функции на удобные для тестирования версии.

Это особенно удобно при получении данных. Обычно, предпочтительнее использовать «подставные» данные для тестов, чтобы избежать замедления и странного поведения, чем получать данные из настоящих API. [<small>(пример)</small>](/docs/testing-recipes.html#data-fetching). Это сделает тесты более предсказуемыми. Библиотеки, такие как, [Jest](https://jestjs.io/) и [sinon](https://sinonjs.org/), поддерживают подмену функций. В «сквозных» тестах, подменить сетевой интерфейс будет тяжелее, но вы, возможно, захотите протестировать и настоящие API в таких тестах.

### Фиктивные модули {#mocking-modules}

Некоторые компоненты имеют зависимости в виде модулей, могут неправильно работать внутри тестовой среды или совсем не нужны при тестировании. Выборочная подмена таких модулей на фиктивные может быть полезна [<small>(пример)</small>](/docs/testing-recipes.html#mocking-modules).

В Node.js исполнители тестов, например Jest [поддерживает фиктивные модули](https://jestjs.io/docs/ru/manual-mocks). Вы можете также использовать библиотеки, такие как [`mock-require`](https://www.npmjs.com/package/mock-require).

### Фиктивные таймеры {#mocking-timers}

Компоненты могут использовать функции, связанные с временем, такие как `setTimeout`, `setInterval` или `Date.now`. В средах тестирования подмена таких функции на фиктивные, позволит «двигаться» во времени и может быть полезной. Это отличный способ ускорить выполнение тестов! Тесты с таймерами будут по-прежнему выполнятся по порядку, только быстрее. [<small>(пример)</small>](/docs/testing-recipes.html#timers). Большинство фреймворков, включая [Jest](https://jestjs.io/docs/en/timer-mocks), [sinon](https://sinonjs.org/releases/v7.3.2/fake-timers/) и [lolex](https://github.com/sinonjs/lolex), позволяют подменять таймеры в тестах.

Иногда фиктивные таймеры не нужны. Например, при тестировании анимации или взаимодействии с удаленным API, который чувствителен к времени (имеет ограничение по частоте доступа). Библиотеки с фиктивными таймерами позволяют включать и выключать их для одного теста или набора в целом, так что вы можете явно указать, как эти тесты будут исполняться.

### «Сквозные» тесты {#end-to-end-tests-aka-e2e-tests}

«Сквозные» тесты полезны при тестировании длинных последовательностей действий, особенно тех, что важны для бизнеса (таких как платежи или регистрация пользователей). Для таких тестов, вы скорее всего, хотите протестировать рендеринг полного приложение в настоящем браузере, получение данных из настоящих API, использование сессий и кук, переходы по ссылкам. Еще вы, возможно, захотите проверить вероятный результат не только состояния DOM, но и сохранения данных (например проверить, были ли изменения сохранены в базе данных).

В этом случае вам стоит использовать фреймворк [Cypress](https://www.cypress.io/) или библиотеку [puppeteer](https://github.com/GoogleChrome/puppeteer) так вы сможете перемещаться между несколькими маршрутами и проверять вероятные побочные эффекты не только в браузере, но и, возможно, на бэкенде.
